package main

import (
	"bytes"
	"crypto/sha256"
	"flag"
	"hash"
	"log"
	"math"
	"math/big"
	"math/rand"
	"time"
)

var (
	g  *big.Int
	g_ *big.Int
	p  *big.Int
	q  *big.Int
	h  *big.Int
	num int
)

type Ciphertext struct {
	C  *big.Int `json:"c"`
	U  *big.Int `json:"u"`
	U_ *big.Int `json:"u_"`
	E  *big.Int `json:"e"`
	F  *big.Int `json:"f"`
}

type DecryptionShare struct {
	Id          int      `json:"id"`
	U           *big.Int `json:"u"`
	CiphertextU *big.Int `json:"ciphertextU"`
	E           *big.Int `json:"e"`
	F           *big.Int `json:"f"`
	H           *big.Int `json:"h"`
}

func getRandomBigInt() *big.Int {
	min := math.MaxInt16
	max := math.MaxInt32
	return big.NewInt(int64(min + rand.Intn(max-min)))
}

func hash256(h hash.Hash, paras ...[]byte) []byte {
	data := new(bytes.Buffer)
	for _, v := range paras {
		data.Write(v)
	}
	h.Write(data.Bytes())
	result := h.Sum(nil)
	h.Reset()
	return new(big.Int).Mod(new(big.Int).SetBytes(result), p).Bytes()
}

func Encrypt(publicKey *big.Int, m *big.Int) *Ciphertext {
	// encryption
	r := getRandomBigInt()
	s := getRandomBigInt()
	hr := new(big.Int).Exp(publicKey, r, p)
	hashOfhr := new(big.Int).SetBytes(hash256(sha256.New(), hr.Bytes()))

	c := new(big.Int).Xor(hashOfhr, m)
	u := new(big.Int).Exp(g, r, p)
	w := new(big.Int).Exp(g, s, p)
	u_ := new(big.Int).Exp(g_, r, p)
	w_ := new(big.Int).Exp(g_, s, p)
	e := new(big.Int).SetBytes(hash256(sha256.New(), c.Bytes(), u.Bytes(), w.Bytes(), u_.Bytes(), w_.Bytes()))
	f := new(big.Int).Mod(new(big.Int).Add(s, new(big.Int).Mul(r, e)), p)

	return &Ciphertext{
		C:  c,
		U:  u,
		U_: u_,
		E:  e,
		F:  f,
	}
}

func getFakeShare(ciphertext *Ciphertext, id int) *DecryptionShare {
	return &DecryptionShare{
		Id:          id,
		U:           ciphertext.U,
		CiphertextU: ciphertext.U_,
		E:           ciphertext.E,
		F:           ciphertext.F,
		H:           ciphertext.E,
	}
}

func getInterpolationCoefficients(shares []*DecryptionShare, id int) *big.Int {
	product := big.NewInt(1)
	for _, v := range shares {
		if id != v.Id {
			tmp := new(big.Int).Mul(big.NewInt(int64(0-v.Id)), new(big.Int).ModInverse(big.NewInt(int64(id-v.Id)), q))
			product.Mul(product, tmp)
			product.Mod(product, q)
		}
	}

	return product
}

// len of decryption share is t + 1
func CombineShares(ciphertext *Ciphertext, shares []*DecryptionShare) *big.Int {
	productU := big.NewInt(1)
	for _, v := range shares {
		interpolation := getInterpolationCoefficients(shares, v.Id)
		tmp := new(big.Int).Exp(v.U, interpolation, p)
		productU.Mul(productU, tmp)
		productU.Mod(productU, p)
	}

	hOfProductU := new(big.Int).SetBytes(hash256(sha256.New(), productU.Bytes()))
	m := new(big.Int).Xor(hOfProductU, ciphertext.C)
	return m
}

func calFuncTime(f func(),funcDescription string) {
	startTime := time.Now()
	f()
	endTime := time.Now()
	log.Println(funcDescription,"total time:", endTime.Sub(startTime))
}

func init() {
	g, _ = new(big.Int).SetString("2141434891434191460597654106285009794456474073127443963580690795002163321265105245635441519012876162226508712450114295048769820153232319693432987768769296824615642594321423205772115298200265241761445943720948512138315849294187201773718640619332629679913150151901308086084524597187791163240081868198195818488147354220506153752944012718951076418307414874651394412052849270568833194858516693284043743223341262442918629683831581139666162694560502910458729378169695954926627903314499763149304778624042360661276996520665523643147485282255746183568795735922844808611657078638768875848574571957417538833410931039120067791054495394347033677995566734192953459076978334017849678648355479176605169830149977904762004245805443987117373895433551186090322663122981978369728727863969397652199851244115246624405814648225543311628517631088342627783146899971864519981709070067428217313779897722021674599747260345113463261690421765416396528871227", 10)
	g_, _ = new(big.Int).SetString("2141434891434191460597654106285009794456474073127443963580690795002163321265105245635441519012876162226508712450114295048769820153232319693432987768769296824615642594321423205772115298200265241761445943720948512138315849294187201773718640619332629679913150151901308086084524597187791163240081868198195818488147354220506153752944012718951076418307414874651394412052849270568833194858516693284043743223341262442918629683831581139666162694560502910458729378169695954926627903314499763149304778624042360661276996520665523643147485282255746183568795735922844808611657078638768875848574571957417538833410931039120067791054495394347033677995566734192953459076978334017849678648355479176605169830149977904762004245805443987117373895433551186090322663122981978369728727863969397652199851244115246624405814648225543311628517631088342627783146899971864519981709070067428217313779897722021674599747260345113463261690421765416396528871227", 10)
	p, _ = new(big.Int).SetString("3268470001596555685058361448517594259852327289373621024658735136696086397532371469771539343923030165357102680953673099920140531685895962914337283929936606946054169620100988870978124749211273448893822273457310556591818639255714375162549119727203843057453108725240320611822327564102565670538516259921126103868685909602654213513456013263604608261355992328266121535954955860230896921190144484094504405550995009524584190435021785232142953886543340776477964177437292693777245368918022174701350793004000567940200059239843923046609830997768443610635397652600287237380936753914127667182396037677536643969081476599565572030244212618673244188481261912792928641006121759661066004079860474019965998840960514950091456436975501582488835454404626979061889799215263467208398224888341946121760934377719355124007835365528307011851448463147156027381826788422151698720245080057213877012399103133913857496236799905578345362183817511242131464964979", 10)
	q, _ = new(big.Int).SetString("93911948940456861795388745207400704369329482570245279608597521715921884786973", 10)
	h, _ = new(big.Int).SetString("2141434891434191460597654106285009794456474073127443963580690795002163321265105245635441519012876162226508712450114295048769820153232319693432987768769296824615642594321423205772115298200265241761445943720948512138315849294187201773718640619332629679913150151901308086084524597187791163240081868198195818488147354220506153752944012718951076418307414874651394412052849270568833194858516693284043743223341262442918629683831581139666162694560502910458729378169695954926627903314499763149304778624042360661276996520665523643147485282255746183568795735922844808611657078638768875848574571957417538833410931039120067791054495394347033677995566734192953459076978334017849678648355479176605169830149977904762004245805443987117373895433551186090322663122981978369728727863969397652199851244115246624405814648225543311628517631088342627783146899971864519981709070067428217313779897722021674599747260345113463261690421765416396528871227", 10)
	flag.IntVar(&num,"num",32,"number of servers")
	flag.Parse()
}

func main() {
	log.Println("current num:",num)
	var pubKey *big.Int
	var m *big.Int

	// set public key
	for {
		pk := make([]byte, 384)
		_, err := rand.Read(pk)
		if err != nil {
			panic(err)
		}
		pubKey = new(big.Int).SetBytes(pk)
		if pubKey.BitLen() == 384*8 {
			break
		}
	}

	// set message
	m = big.NewInt(2131231432424)
	ciphertext:=Encrypt(pubKey,m)

	calFuncTime(func(){
		Encrypt(pubKey,m)
	},"encryption")

	// get fake decryption shares
	t:= int(math.Ceil(float64(num)/3))
	shares:= make([]*DecryptionShare,0,t+1)
	for i:=0;i<num;i++ {
		shares=append(shares,getFakeShare(ciphertext,i+1))
	}
	// combining shares
	calFuncTime(func(){
		CombineShares(ciphertext,shares)
	},"combine shares")
}
